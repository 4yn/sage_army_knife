

# This file was *autogenerated* from the file /home/sy/ctf2/sage_army_knife/sage_army_knife/script_bag/mimoo_dh_backdoor.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1024 = Integer(1024); _sage_const_30 = Integer(30); _sage_const_20 = Integer(20); _sage_const_40 = Integer(40)# mimoo_dh_backdoor.sage
# Author: David Wong / https://twitter.com/cryptodavidw / https://github.com/mimoo
# Source: https://github.com/mimoo/Diffie-Hellman_Backdoor
# URL: https://raw.githubusercontent.com/mimoo/Diffie-Hellman_Backdoor/master/backdoor_generator/backdoor_generator.sage
# md5sum: 37bc1ad725e47a4b95c1df24877991d0

#################################################################
# DH Backdoor generator
#################################################################
# This tool generates Diffie-Hellman parameters
# that would allow for a backdoor.
#
# several method are availables
################################################################# 

import sys, pdb, time

################################################################# 
# Helpers
################################################################# 

# colors
class cc:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
            
################################################################# 
# Methods
################################################################# 

# CM_HDSS helper
# prime p - 1 = 2 * p_1 * p_2 -> returns p, p_1
def subgroup_prime(prime_size, small_factor_size):
    """ generate a prime `p` s.t. `p - 1 = 2 * small_factor * large_factor`
    with `small_factor` a prime of size `small_factor_size`
    and `p` of size `prime_size`
    """
    p = _sage_const_0 

    # fixed large factor
    large_factor_size = prime_size - small_factor_size
    large_factor = random_prime(_sage_const_1 <<(large_factor_size+_sage_const_1 ),
                                lbound=_sage_const_1 <<(large_factor_size-_sage_const_3 ))

    while not is_prime(p):
        # find a small factor
        small_factor = random_prime(_sage_const_1 <<(small_factor_size+_sage_const_1 ),
                                    lbound=_sage_const_1 <<(small_factor_size-_sage_const_3 ))

        # p
        p = _sage_const_2  * small_factor * large_factor + _sage_const_1 
    #
    return p, small_factor

# Composite Modulus Hidden Small Subgroup
def CM_HDSS(modulus_size, subgroup_size):
    """ n = p * q, s.t. p-1 and q-1 are of the form
    2 * small_factor * large_factor
    the generator g mod p and mod q lies in the small subgroup
    the large factor is here to prevent against Pollard's p-1 factorization
    """
    # set the group
    prime_size = modulus_size//_sage_const_2 
    p, p_order = subgroup_prime(prime_size, subgroup_size)
    q, q_order = subgroup_prime(prime_size, subgroup_size)
    n = p * q

    # find a generator
    g = _sage_const_2 
    while power_mod(g, p_order*q_order, n) != _sage_const_1  or power_mod(g, p_order, n) == _sage_const_1  or power_mod(g, q_order, n) == _sage_const_1 :
        g = power_mod(randint(_sage_const_2 , n-_sage_const_1 ), (p-_sage_const_1 )*(q-_sage_const_1 )//(p_order*q_order), n)

    # print
    print("modulus          =", n)
    print("bitlength        =", len(bin(n)) - _sage_const_2 )
    print("p, q             =", p, ", ", q)
    print("generator        =", g)
    print("order_p, order_q =", p_order, ", ", q_order)

    #
    return g, n, p, q, p_order, q_order

# CM_HSO helper
def B_smooth(total_size, small_factors_size, big_factor_size):
    """ Just picking at random should be enough, there is a very small probability
    we will pick the same factors twice
    """
    smooth_prime = _sage_const_2 
    factors = [_sage_const_2 ]
    # large B-sized prime
    large_prime = random_prime(_sage_const_1 <<(big_factor_size + _sage_const_1 ), lbound=_sage_const_1 <<(big_factor_size-_sage_const_3 ))
    factors.append(large_prime)
    smooth_prime *= large_prime
    # all the other small primes
    number_small_factors = (total_size - big_factor_size) // small_factors_size
    i = _sage_const_0 
    for i in range(number_small_factors - _sage_const_1 ):
        small_prime = random_prime(_sage_const_1 <<(small_factors_size + _sage_const_1 ), lbound=_sage_const_1 <<(small_factors_size-_sage_const_3 ))
        factors.append(small_prime)
        smooth_prime *= small_prime
    # we try to find the last factor so that the total number is a prime
    # (it should be faster than starting from scratch every time)
    prime_test = _sage_const_0 
    while not is_prime(prime_test):    
        last_prime = random_prime(_sage_const_1 <<(small_factors_size + _sage_const_1 ), lbound=_sage_const_1 <<(small_factors_size-_sage_const_3 ))
        prime_test = smooth_prime * last_prime + _sage_const_1 

    factors.append(last_prime)
    smooth_prime = smooth_prime * last_prime + _sage_const_1 

    return smooth_prime, factors

# recursive function to find the order of a base g
def find_order(g, order, modulus, factors):
    for index, factor in enumerate(factors):
        # if one factor is not part of the order we descend
        if power_mod(g, order//factor, modulus) == _sage_const_1 :
            new_factors = list(factors)
            new_factors.pop(index)
            return find_order(g, order//factor, modulus, new_factors)
    # all factors are part of the order
    return order, factors

# Composite Modulus Hidden Smooth Order
def CM_HSO(modulus_size, small_factors_size, big_factor_size, generator=_sage_const_0 ):
    """ n = p * q, s.t. p-1 and q-1 are B-smooth (for Pohlig-Hellman)
    with B large enough to counter Pollard's p-1 factorization algorithm
    latest records of Pollard's p-1 used B = 10^15 (~50bits)
    p-1, q-1 will have one factor of size `upper_smooth_size` and all others of size `smooth_size`
    """
    # p - 1 = B_prime * small_prime_1 * small_prime2 * ...
    p, p_factors = B_smooth(modulus_size//_sage_const_2 , small_factors_size, big_factor_size)
    q, q_factors = B_smooth(modulus_size//_sage_const_2 , small_factors_size, big_factor_size)
    factors = p_factors + q_factors

    # modulus
    modulus = p * q

    # the order of the generator we ideally want
    order = (p-_sage_const_1 )*(q-_sage_const_1 )

    # find a random generator
    if generator == _sage_const_0 :
        gp = GF(p).multiplicative_generator()
        gq = GF(q).multiplicative_generator()
        g = CRT(int(gp), int(gq), p, q)
        order, factors = find_order(g, order, modulus, factors)
    # use a specific generator
    else:
        g = generator
        factors = factors[_sage_const_1 :] # remove the first 2 (lcm)
        order, factors = find_order(g, order, modulus, factors)

    # split order
    p_order = order % (p-_sage_const_1 )
    q_order = order % (q-_sage_const_1 )

    if p_order == _sage_const_0 :
        p_order = p-_sage_const_1 
    if q_order == _sage_const_0 :
        q_order = q-_sage_const_1 

    # split factors
    if p_order != p-_sage_const_1  or q_order != q-_sage_const_1 :
        p_factors, q_factors = [], []
        for factor in factors:
            if p-_sage_const_1  % factor == _sage_const_0 :
                p_factors.append(factor)
            if q-_sage_const_1  % factor == _sage_const_0 :
                q_factors.append(factor)

    # print
    print("modulus          =", modulus)
    print("bitlength        =", len(bin(modulus)) - _sage_const_2 )
    print("p, q             =", p, ",", q)
    print("p_order          =", p_order)
    print("q_order          =", q_order)
    print("p_factors        =", p_factors)
    print("q_factors        =", q_factors)
    print("generator        =", g)

    # ->
    return g, modulus, p, q, factors

# same as CM-HSO except the order of g doesn't have big groups
def CM_HSO_HSS(modulus_size, small_factors_size, big_factor_size):
    """ n = p * q, s.t. p-1 and q-1 are B-smooth (for Pohlig-Hellman)
    with B large enough to counter Pollard's p-1 factorization algorithm
    latest records of Pollard's p-1 used B = 10^15 (~50bits)
    p-1, q-1 will have one factor of size `upper_smooth_size` and all others of size `smooth_size`
    """
    # p - 1 = B_prime * small_prime_1 * small_prime2 * ...
    p, p_factors = B_smooth(modulus_size//_sage_const_2 , small_factors_size, big_factor_size)
    q, q_factors = B_smooth(modulus_size//_sage_const_2 , small_factors_size, big_factor_size)
    factors = p_factors + q_factors

    # modulus
    modulus = p * q

    # the order of the non-cyclic group
    order = (p-_sage_const_1 )*(q-_sage_const_1 )
    # the maximum order of a subgroup
    order_max = (p-_sage_const_1 )*(q-_sage_const_1 )//_sage_const_2 
    # the order targeted by our generator
    order_target = (p-_sage_const_1 )*(q-_sage_const_1 )//(p_factors[_sage_const_1 ] * q_factors[_sage_const_1 ])

    # find a random generator
    order_final = order_max
    while order_final >= order_target:
        gp = GF(p).multiplicative_generator()
        gp = power_mod(gp, p_factors[_sage_const_1 ], p)
        gq = GF(q).multiplicative_generator()
        gq = power_mod(gq, q_factors[_sage_const_1 ], q)
        g = CRT(int(gp), int(gq), p, q)
        order_final, factors = find_order(g, order, modulus, factors)
                    
    # split order
    p_order = order % (p-_sage_const_1 )
    q_order = order % (q-_sage_const_1 )

    if p_order == _sage_const_0 :
        p_order = p-_sage_const_1 
    if q_order == _sage_const_0 :
        q_order = q-_sage_const_1 

    # split factors
    if p_order != p-_sage_const_1  or q_order != q-_sage_const_1 :
        p_factors, q_factors = [], []
        for factor in factors:
            if p-_sage_const_1  % factor == _sage_const_0 :
                p_factors.append(factor)
            if q-_sage_const_1  % factor == _sage_const_0 :
                q_factors.append(factor)

    # print
    print("modulus          =", modulus)
    print("bitlength        =", len(bin(modulus)) - _sage_const_2 )
    print("p, q             =", p, ",", q)
    print("p_order          =", p_order)
    print("q_order          =", q_order)
    print("p_factors        =", p_factors)
    print("q_factors        =", q_factors)
    print("generator        =", g)

    # ->
    return g, modulus, p, q, factors


################################################################# 
# Main menu
################################################################# 

menu = [
    "composite modulus with hidden small subgroup (CM-HSS)",
    "composite modulus with B-smooth order (CM-HSO)"
        ]

def main():
    # display menu if not provided with an option
    if len(sys.argv) < _sage_const_2 :
        sys.stderr.write("\x1b[2J\x1b[H")
        print(cc.HEADER + "# Choose a method from:" + cc.END)
        for index, item in enumerate(menu, _sage_const_1 ):
            print("%d. %s" % (index, menu[index - _sage_const_1 ]))
        print("(you can also pass that choice as an argument)")
        # prompt
        choice = int(raw_input(cc.OKGREEN + "# Enter a digit:\n" + cc.END))
        sys.stderr.write("\x1b[2J\x1b[H")
    else:
        choice = int(sys.argv[_sage_const_1 ])

    # run method
    if choice == _sage_const_1 :
        g, n, p, q, p_order, q_order = CM_HSS(_sage_const_1024 , _sage_const_30 )
    elif choice == _sage_const_2 :
        g, n, p, q, factors = CM_HSO(_sage_const_1024 , _sage_const_20 , _sage_const_40 , _sage_const_2 )

if __name__ == "__main__":
    main()
else:
    #g, n, p, q, factors = CM_HSO(1024, 20, 40, 2)
    # g, n, p, q, factors = test(1024, 20, 40)
    pass


