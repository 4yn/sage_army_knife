

# This file was *autogenerated* from the file /home/sy/ctf2/sage_army_knife/src/sage_army_knife/dot_sage/curve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0)
def two_points_to_a4_a6(p, x1, y1, x2, y2):
    F = Zmod(p)
    x1, y1, x2, y2 = [
        F(ZZ(i))
        for i in [x1, y1, x2, y2]
    ]

    a4, a6 = Matrix(F, [
        [x1, _sage_const_1 ],
        [x2, _sage_const_1 ]
    ]).solve_right(vector(F, [
        y1 ** _sage_const_2  - x1 ** _sage_const_3 , y2 ** _sage_const_2  - x2 ** _sage_const_3 
    ]))

    assert y1 ** _sage_const_2  == x1 ** _sage_const_3  + x1 * a4 + a6
    assert y2 ** _sage_const_2  == x2 ** _sage_const_3  + x2 * a4 + a6

    return ZZ(a4), ZZ(a6)

def is_curve_singular(*args, **kwargs):
    try:
        EllipticCurve(*args, **kwargs)
    except ArithmeticError as e:
        return "singular" in str(e)
    return False

def solve_singular_node(p, a, b, gx, gy, px, py):
    # https://ctftime.org/writeup/12563
    # https://crypto.stackexchange.com/questions/61302/how-to-solve-this-ecdlp
    
    F = Zmod(p)['x']; (x,) = F._first_ngens(1)
    rhs = x ** _sage_const_3  + a * x + b
    rhs_factor = rhs.factor()
    assert len(rhs_factor) == _sage_const_2 

    linear_shift = [
        poly
        for poly, exp in rhs_factor
        if exp == _sage_const_2 
    ][_sage_const_0 ].coefficients()[_sage_const_0 ]

    rhs_shift_factor = rhs.subs(x=x-linear_shift).factor()
    scale_shift = F([
        poly
        for poly, exp in rhs_shift_factor
        if exp == _sage_const_1 
    ][_sage_const_0 ].coefficients()[_sage_const_0 ]).sqrt()

    gx_, px_ = [
        i + linear_shift
        for i in [gx, px]
    ]

    gz, pz = [
        (y + scale_shift * x) / (y - scale_shift * x)
        for x, y in [(gx_, gy), (px_, py)]
    ]

    sk = discrete_log(pz, gz)
    return ZZ(sk)

def solve_singular_cusp(p, gx, gy, px, py):
    F = Zmod(p)['x']; (x,) = F._first_ngens(1)
    gx, gy, px, py = [
        F(ZZ(i))
        for i in [gx, gy, px, py]
    ]
    gz = gx / gy
    pz = px / py
    return ZZ(pz / gz)

